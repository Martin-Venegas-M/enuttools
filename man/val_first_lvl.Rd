% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/val_first_lvl.R
\name{val_first_lvl}
\alias{val_first_lvl}
\title{Validate questions in a survey dataset}
\usage{
val_first_lvl(data, variables, expressions)
}
\arguments{
\item{data}{A data frame containing the survey data.}

\item{variables}{A character vector with the names of the variables to validate.}

\item{expressions}{A character vector of R expressions specifying the enabling}
}
\value{
A wide \code{data.frame} with dummy columns indicating validation errors.
}
\description{
This function creates a data frame with dummy columns indicating whether each
variable in a survey dataset meets first-level validation criteria.
}
\details{
The first-level validation criteria are:

\enumerate{
  \item The cell value is allowed by the enabling condition associated with the column.
  \item The cell value falls within the expected range for the column.
}

These criteria can produce the following types of errors:
\itemize{
  \item \strong{error1}: Missing value. The response is missing, even though the enabling condition indicates there should be a response.
  \item \strong{error2}: Failed filter. A response is present, even though the enabling condition indicates there should be no response.
  \item \strong{error3}: Out of range. The response is outside the expected range.
}

For each variable evaluated, the function generates up to three new columns
(one per error type). If \eqn{c} columns are validated, the output will contain
\eqn{c * 3} columns. Each column is a dummy variable indicating with \eqn{1} whether
the error occurred for that case.

The function assumes the existence of a structured metadata input that includes
the question name (column name), enabling condition, valid range, and type of range.
}
\examples{
df <- tibble::tibble(x = c(1, 1, 0), y = c(1, NA, NA))

# You can uses string or expression inputs
val_first_lvl(df, "y", "x == 1")
val_first_lvl(df, y, x == 1)

# Or even a combination...
val_first_lvl(df, "y", x == 1)
val_first_lvl(df, y, "x == 1")

# Also accepts vectors!
val_first_lvl(df, variables = c(x, y), expressions = c(TRUE, x == 1))
val_first_lvl(df, variables = c("x", "y"), expressions = c("TRUE", "x == 1"))
}
